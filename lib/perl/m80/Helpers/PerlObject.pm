#
# There are 2 types of code in this file :
# 1) Code that generates code
# 2) Code that determines what code should be generated - true object code
#
# The functions are all classified as such
# 

package m80::Helpers::PerlObject;

use Carp;
use Data::Dumper;
use Term::ANSIColor qw(:constants);
use shellHelpers;

sub Confess {confess BOLD, RED, @_, RESET}

#
# _scalarOrCode()   : internal Fn
#
# used during the GetOpts 'default' expansion. If the default looks like code
# then it will just return it, if not, then it will quote it.
# 
sub _scalarOrCode {
    my $arg = shift;
    if ($arg !~ /(^new\s|::|&|\(.*\)|\$|\@|\%|^\[|^\{)/) {    # try to guess if it is a scalar or not
        return '"' . $arg . '"';                      # if it is scalar, then quote it.
    }
    return $arg;
}

#
# newObject()  : generatesCode
#
# produces a class file header that contains compilation information and pod documentation
# 

sub newObject
{
    my $this = shift;
    my %args = @_;
    my $ret;

    Confess "No Object description: use description argument" unless $this->{description};

    $whoami = `whoami`;
    chomp($whoami);
    $hostname = `hostname`;
    chomp($hostname);
    $uname = `uname -a`;
    chomp($uname);


    $ret .= "

=pod

=head1 NAME - $this->{name}

$this->{description}

=head1 EXAMPLE

" . ($this->{example} ? $this->{example} : "No example(s) have been documented for this object.") . "

=cut

# This file was automatically generated from $ENV{M80PATH_FILE} by 
# $whoami on $hostname ($uname)
# DO NOT EDIT THIS FILE 


package $this->{name};

use Carp;
use Data::Dumper;
use Term::ANSIColor qw(:constants);
use strict;
sub Confess (@) {confess BOLD, RED, \@_, RESET}

";

    $ret .= shellHelpers::printmsg();

    map {
        $ret .= "use $_;\n";
    } (@{$this->{include}});

    if ($this->{isa}) {
        $ret .= "
use base qw($this->{isa});

=pod

=head1 INHERITANCE

$this->{name} extends class $this->{isa} ; refer to the documentation for that object for member variables and methods.

=cut

";
    }

    $ret .= "use fields qw(";

    my $members = $this->{members};

    if ($members) {
	map {
            $ret .= " $_->{name}";
	} (@{$members});
    }
    $ret .= " );";
    return $ret;
}

#
# constructor(%args)  : generatesCode
#
# produces a constructor for the class that is being defined. The constructor is called 'new'.
# It does the following processing in order:
#
#  - argument processing
#  - __new()
#  - $this->SUPER::new()
#  - _new()
#
# Argument processing is done with the setter that corresponds to each field name.
#
# That requires more detail:
# The generated class contains 2 hashes named %_allSetters and %_allMembers. These hashes
# have the same keys, but the setters hash contains pointers to the setter function for a
# particular key. The members hash just contains a true value.
#
# A user can get at this class meta information by referencing it explicitly :
#  --     my $class_fields = keys %{ *{ "$class::_allSetters" } }
#
# The constructor is also going to check that there are not arguments that fall outside
# the range of fields. If it finds one of these, it will error.
# 

sub constructor
{
    my $this = shift;
    my %args = @_;
    my $ret;

    $ret .= "

=pod

=head1 CONSTRUCTOR

=over 4

=item $this->{name}" . '->'."new()

initializes on object of type $this->{name}

=back

=cut

";

    #
# generate a lookup table for all valid member variables
#

    $ret .= '


# %_allSetters - an array of all setters for all members of the class
my %_allSetters = ();

my %_allMemberAttributes = ();
# $_allMembers{_TYPE} = 1; # - WHAT IS THIS FOR?
';
    my $members = $this->{members};

    if ($members) {
	map {
            my $reflection = Data::Dumper->new([$_]);
            $reflection->Purity(1)->Terse(1)->Deepcopy(1);
            $ret .= '$_allMemberAttributes{' . $_->{name} . "} = " . $reflection->Dump() . ";\n";
	    $ret .= '$_allSetters{' . $_->{name} . "} = \\\&set" . ucFirstChar($_->{name})  . ";\n";  
	} (@{$members});

    }

    $ret .= '

sub getReflectionAPI { return %_allMemberAttributes }

sub new {
    my ' . $this->{name} . ' $this = shift;

    print STDERR "in ' . $this->{name} . '::new(" . join (",", @_) . ")\n" if $ENV{DEBUG};
    Confess "Missing the value for an argument (even nulls) on creation of ' . $this->{name} . '" if scalar @_ % 2 != 0;

    my %args = @_;

    unless (ref $this) {
	$this = fields::new($this);
    }

    #
    # This next block tries to set any of the values that you passed into this
    # constructor. You might have said new X( arg1 => 123, arg2 => 456); It is going
    # to take that and try to call setArg1(123), setArg2(123). I.e. it is going
    # to derive the setter for your named argument (by upper casing the first letter
    # of your argument name) and then if it finds that the object can call the
    # setter (i.e. it is defined in this class or any parent class) it will call it.
    #
    # If the setter cannot be found - then assume that this is a bad argument
    # that was passed to the function and die with that information.
    #
    foreach my $key (keys(%args)) {

        my $setterName = $key;                              # workspace for determining the name of the setter
        $setterName =~ s/^(\w)/uc($1)/e;                    # uc the first char of the argument name. I.e. arg1 => Arg1.
        $setterName = "set" . $setterName;                  # prepend "set" to the uppercased argument name.

        if (my $fn = $this->UNIVERSAL::can($setterName)) {  # test that the object can call this function
            $fn->($this,$args{$key});                       # and call it
        } else {                                            # else fail with an error. 
            Confess "Field named \"$key\" is not defined in object ' . $this->{name} . '. typo ?\n";
        }
    }

';
    $ret .= '    $this->trace( ref($this) );' . "\n" if $this->{traceOn};

  if ($members) {
	map {

            if ($_->{default}) {
                my $default = _scalarOrCode( $_->{default} );
                $ret .= "
    \$this->{$_->{name}} = $default unless defined \$this->{$_->{name}};
";
            }

            $ret .= "
    Confess \"cannot initialize object of type $this->{name} without required member variable $_->{name}\"
        unless exists \$this->{$_->{name}};
" if $_->{required};

	} (@{$members});
    }


# CallOrder:
#
# $this->__new()
# SUPER->new()
# $this->_new();
#

$ret .= '

    eval {
	' . $this->{name} . '::__new($this,%args);
    };

    croak $@ if $@
	and $@ !~ /^Undefined subroutine/;


    eval {
	$this->SUPER::new(%args);
    };

    croak $@ if $@
	and $@ !~ /^Can\\\'t locate object method/;

    eval {
	' . $this->{name} . '::_new($this,%args);
    };

    croak $@ if $@
	and $@ !~ /^Undefined subroutine/;

    return $this;
}
';

    return $ret;
}


#
# new() : thisObjectConstructor
#
# This is used to return a PerlObject object. A PerlObject has the following fields
# (and the new function supports the following arguments):
#
# - name : documentation
# - description : documentation
# - example : documenation
# - where : documentation - defaults to the p4 path to the file if 'file' is specified in the arg list.
# - include : A list of .pm files that should be 'used'
# - isa : A list of classes for the @ISA array
# - traceOn : turn on tracing of the class
# - noConstructor : Boolean - if specified, the 'constructor()' fn isn't called
# - members : ARRAY - the fields in this object. Will be used to generate setters/getters
# - interface : ARRAY - the interface that this object should require. Creates Virtual Fn for each fn defined.
# - callbacks : ? - doesn't look like it is implemented
#
# The following structures are defined in this object - implicitly:
#
# The "GetOpts" Structure (an array that contains a hash for each option):
#    - name : REQUIRED; the name of the option - this might be a command line arg, or it might be a member name
#    - description : REQUIRED; a description of the option - for docs and whatnot
#    - default : OPTIONAL; if provided, the default value will be used unless another value is in the arg list.
#    - required : OPTIONAL; boolean - if true, the option is required by the fn
#    - message  : OPTIONAL; the message that is returned if the object fails the 'ref' test. The default message
#                 includes info related to ->isa() and is non-intuitive for a non Perl person. Use this field
#                 to change the message to something more relevant. Quoting Trick: Use ' to define the message
#                 in the getopts hash. The expansion will be based on ", so you can do variable expansion in your message if you
#                 get the quoting right.
#    - ref : OPTIONAL; The type of an argument. Defaults to ref eq '' or string
#    - format : OPTIONAL; This is superceeded by ref. If ref is specified - this field will be ignored!
#               A regexp that will be used in the contract to determine if the argument value is acceptable
#    - positionalParameters : OPTIONAL; The arguments passed to a generated function are in a hash by default.
#                             This allows for named arguments. If you want to override this, then specify
#                             this field as part of the getOpts call.
#
# The "Members" Structure:
#    - Exactly the same as the GetOpts structure. The name of the option is the name of the member.
#
# The "Methods" Structure (internal hash containing the name of the member pointing at a hash that contains):
#    - description : REQUIRED; a description of the method
#    - positionalParameters : OPTIONAL; see the getopts structure
#    - getopts : OPTIONAL; array - all collection of ordered GetOpts structures
#
#


sub new {
    my ($class, %args) = @_;
    $args{_obj} = {};
    my $name = ref($class) || $class;
    $args{_TYPE_} = $name;
    
    bless \%args, $name;

    my $obj = \%args;
    $obj->setMethods("_new" => {description => "callback constructor, do not call directly use new() instead"});

    $args{file} =~ s/\n//g;
    my $where = `p4 where $args{file}`;
    $where =~ s/(.+?)\s.*/$1/;
    chomp($where);
    $args{where} = $where;

    return \%args;
}


#
# finish()   : generateCode
#
# prints the footer on the class file
# 

sub finish {
    return "
1;

=pod

=head1 NOTES ON THIS DOCUMENTATION

In method signatures a * denotes a required option.

This file was automatically generated from $ENV{M80PATH_FILE} by 
$whoami on $hostname ($uname)


=head1 OBJECT METHODS

=cut

";
}


#
# setMembers()    : thisObjectCode
#
# Use this function to specify the properties of the members in this file. The syntax is like:
#
#  $po->setMembers( [ GetOpt Struct, ... ] )
#

sub setMembers {
    my $this = shift;
    
    $this->{members} = shift;

    my $found = 0;
    my @additional = ( { name => debug, description => 'debug allows an object to specify its debugPrint level' },
#                       { name => trace, description => 'A flag indicating whether trace should be turned on' },
                       );

    if ($ENV{TRACE}) {
        $this->{traceOn} = 1;
    }

    for my $add (@additional) {
        for my $m (@{ $this->{members} } ) {
            if ($m->{name} eq $add->{name}) {
                $found++;
            }
        }
        unless ($found) {
            push @{$this->{members}}, $add;
        }
    }

}


#
# setInterface()    : thisObjectCode
#
# Use this function to specify the interface of this class. The syntax is like:
#
#  $po->setInterface( [ { name => 'methodName', description => 'method description' }, ... ] )
#
sub setInterface {
    my $this = shift;
    
    $this->{interface} = shift;
}



#
# ucFirstChar()    : internal Fn
#
# This is used to standardize the names of the setters and getters. That is the name
# should always be 'set' . ucFirstChar($_[0]) or 'get' . ucFirstChar($_[0])
# 
sub ucFirstChar {
    my $val = shift;

    return uc(substr($val,0,1)) . substr ($val,1);
}


#
# generateSettersAndGetters()   : generateCode
#
# Loop through all the $this->{members}, create $this->{methods} for the setters and getters
# and then dumpContract on all of those definitions. This has the effect of printing out all
# the code necessary for specifying setters and getters.
# 
sub generateSettersAndGetters {
    my $this = shift;
    my $member = shift;
    my $ret = "";

    my $name = $member->{name};
    my $functionName = ucFirstChar($member->{name});

    my $memberType = ( $member->{ref} ? $member->{ref} : ($member->{format} ?
							      "\"$member->{format}\"" : "\"any string\""));
    my $memberStr .= $member->{name} . " => " . $memberType
	. ($member->{required} ? "*" : "");

    if ($member->{default}) {
        my $default = _scalarOrCode( $member->{default} );
        $memberStr .= " (default: $default)";
    }
	$ret .= "

=pod

=head2 $memberStr

$member->{description}

=cut

";

    delete $member->{default};

    $this->setMethods ("get" . $functionName => { description => "getter for member $member->{name}",
						  positionalParameters => "T",},
		       "set" . $functionName => { description => "setter for member $member->{name}",
						  positionalParameters => "T",
						  getopts => [$member],});


    $ret .= "sub get$functionName {\n" . $this->dumpContract(method => "get" . $functionName) . "\n    return \$this->{$name};\n}\n";
    # I've made a change where the passed in value is returned by the setter - this allows you to do things like
    # "return $this->setSomething(something);" in other functions.a
    $ret .= "sub set$functionName {\n" . $this->dumpContract(method => "set" . $functionName) . "\n    \$this->{$name} = \$$name;\n    return \$$name;
}
\n";
    
    return $ret;
}


#
# generateMembers()   : generateCode
#
# For each member that is defined, generate documentation associated with it and
# then call into generateSettersAndGetters for that member.
# 
sub generateMembers {
    my $this = shift;
    my $members = $this->{members};
    my $ret = "";

    $ret .= "
=pod

=head1 MEMBERS AND MEMBER ACCESS METHODS

=cut

";

    map {
	Confess "no description found for variable $_->{name} of object $this->{name}" unless $_->{description};
	$ret .= $this->generateSettersAndGetters($_);

    } (@{$members});


    return $ret;
}


#
# dumpStandardSetters()   : generateCode
#
# The generate object will have a handful of functions that are generated for free.
# These functions are:
#   - _require
#   - ...
#
# This function handles that work. It is called during the dump phase
# 
sub dumpStandardSetters {
    my $ret = "";
    $ret .= '

=pod

=head1 GENERALIZED OBJECT METHODS 

=cut



=pod

=over 4

=item _require (member1,member2,...,memberN)

will iterate over arguments and validate there is a non null value for each of the listed object members

=back

=cut


sub _require
{
    my $this = shift;
    map { 
	Confess "required member variable $_ not set" unless $this->getProperty($_);
    } (@_);
}

';

    return $ret;

}


#
# setMethods()  : internal Fn, thisObjectCode
#
# Use of this function is deprecated in favor of 'contract'. It used to be that a user would
# call this during the definition of their object. They would then reference the methods by
# name later during a 'dumpContract' call. That functionality is exactly replaced with 'contract'.
#
# There are a handful of classes that still use this function, so it lives on... but shouldn't.
# 
sub setMethods {
    my $this = shift;
    my %args = @_;

    foreach my $key (keys(%args)) {
	$this->{methods}->{$key} = $args{$key};
    }
}


#
# contract()   : thisObjectCode
#
# A contract is a concept. It doesn't exist in this detail in a lot of coding systems, but
# it is the notion that the arguments that are passed into a function should be checked
# for things like type (which is the case with most typing languages) but also for additional
# items that are user defined. It might include regexp matches against the values, or format
# checking.
#
# The 'contract' support in PerlObjects is built with 2 main calls:  'contract' defines the
# contract data and 'dumpContract' expands that contract data into working perl code.
#
# This takes a Method Structure as an argument (unnamed).
#   -   contract( methodName => { description => ' ... ', ... } )
#   
sub contract {
    my $this=shift;                              # get the current object
    $this->setMethods(@_);
    return $this->dumpContract(method => shift);
}



#
# dumpContract()   : generateCode
#
# Given a methodName it looks up the contract data for that method and then dumps the perl
# code that implements that contract.
# 
sub dumpContract {
    my $this = shift;
    my %args = @_;
    my $ret ;

    my $method = $args{method};

    $methodObject = $this->{methods}->{$method};

    Confess "no contract defined for method $method of $this->{name}" unless $methodObject;

    my $description = $methodObject->{description};

    # positionalParameters means parameters are in order, not a hash.
    my $positionalParameters = $methodObject->{positionalParameters};
    
    Confess "no description set for method $method of object $this->{name}" unless $description;

    my $optionStr = "(";                      # representation of arguments for pod docs
    my $getopts = $methodObject->{getopts};   # get the options structure
    my $numOptions = 0;                       # count the number of options
    my $optionDescrString;                    # a string used to describe each option on a new line
    my $optionValidationString;               # code for option validation.


    # I'd like this but the "my" variable is a problem.
#    $optionValidationString .= "    eval { \n";
    
    foreach my $option (@{$getopts}) {
	Confess "you attempted to define an option without defining a name for it (use name => parameter).  Object is \n" . Dumper($option)
	    unless ($option->{name});

	$optionStr .= ", " if $numOptions++;
	my $optionType = ( $option->{ref} ? $option->{ref} : ($option->{format} ?
							      "\"$option->{format}\"" : "\"any string\""));
	$optionStr .= $option->{name} . " => " . $optionType
	    . ($option->{required} ? "*" : "");
	Confess "no description set for all arguments to  method $method of object $this->{name}" unless $option->{description};
	my $tab = ((length($option->{name} > 8) ? "\t" : "\t\t"));
	$optionDescrString .= "\n - $option->{name} ($optionType)$tab : $option->{description}";


        if ($option->{default}) {
            
            my $default = _scalarOrCode( $option->{default} );
            $optionDescrString .= " (default: $default)";

            if ($positionalParameters) {
            
                $optionValidationString .= "    my \$$option->{name} = (scalar \@_ ? shift : $default);\n";
            } else {

                $optionValidationString .= "    my \$$option->{name} = (\$args{$option->{name}} ? \$args{$option->{name}} : $default);\n";
            }
        } else {

            if ($positionalParameters) {

                $optionValidationString .= "    my \$$option->{name} = shift;\n";

            } else {

                $optionValidationString .= "    my \$$option->{name} = \$args{$option->{name}};\n";
            }
        }



	if ($option->{required}) {
	    $optionValidationString .= "    Confess \"argument '$option->{name}' is required for $this->{name}"."->$method"."()\" " .
		($positionalParameters 
		 ? "unless defined \$$option->{name};\n"
		 : "unless exists \$args{$option->{name}};\n");
	}
	if ($option->{ref} =~ /^REF/ or
	    $option->{ref} =~ /^CODE/ or
	    $option->{ref} =~ /^SCALAR/ or
	    $option->{ref} =~ /^HASH/ or
	    $option->{ref} =~ /^ARRAY/) {
	    $optionValidationString .= "        if (defined \$$option->{name}) { Confess \"argument '$option->{name}' of method $this->{name}"."->$method"."() is required to be of reference type $option->{ref} \" unless ref(\$$option->{name}) =~ /^$option->{ref}\/;}\n";	    
	} elsif ($option->{ref}) {
	    $optionValidationString .= "    eval {my \$dummy = \$$option->{name}"."->isa(\"$option->{ref}\");};" . 'Confess "' . ($option->{message} ? $option->{message} : '$@') . '\n" . Dumper(' . "\$$option->{name}" . ') if $@;' . "\n"; 
	    $optionValidationString .= "    if (defined \$$option->{name}) { Confess \"argument '$option->{name}' of method $this->{name}"."->$method"."() is required to be of reference type $option->{ref} \" unless \$$option->{name}"."->isa(\"$option->{ref}\");}\n";
	} elsif ($option->{format}) {
	    $optionValidationString .= "        if (defined \$$option->{name}) { Confess \"argument '$option->{name}' of method $this->{name}"."->$method"."() failed format validation of \'" . $option->{format} . "\'\" unless \$$option->{name} =~ /$option->{format}\/;}\n";
	}
	

    }
    $optionStr.=")";

#    $optionValidationString .= '
#    };
#    Confess "$@" if $@;
# ';                                                                             
    
    my $shortName = $this->{name};
    $shortName =~ s/(.+?::)?(.+?)/$2/;
    
    $ret .= "
=pod

=head3 \$$shortName"."->$method $optionStr
$optionDescrString

$description

=cut
";

    my $argumentProcessor =         #code to pull out arguments from the function call (@_)
	($positionalParameters 
	 ? ""
	 : '    confess ref($this) . "->' . $method . ' requires named arguments" if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;' );
	
    $ret .= '
    my $this = shift;
';
    $ret .= '    $this->trace( ref($this) );' . "\n" if $this->{traceOn};
    $ret .= '
'.$argumentProcessor.'
'.$optionValidationString.'
';

    $ret;
}


#
# virtualMethod()   : generateCode
#
# Given the name of a virutal method (from the interface data) - generates a virtual
# method implementation
# 
sub virtualMethod {
    my $this = shift;
    my $method = shift;
    my $ret = "";

    return unless $method->{name};
    my $name = $method->{name};
    $ret .= "

=pod

=head2 $name

$method->{description}

=cut

";

    $ret .= "sub $name { croak 'Virtual method $name called. This should be implemented in a child class.' }\n";
    return $ret;
}


#
# generateInterface()   : generateCode
#
# Loops through all the interface definitions and calls virtualMethod() on the method.
# 
sub generateInterface {
    my $this = shift;
    my $interfaces = $this->{interface};
    my $ret = "";
    my $data = "";

    $ret .= "
=pod

=head1 VIRTUAL METHODS

=cut

";

    map {
	Confess "no description found for variable $_->{name} of object $this->{name}" unless $_->{description};
	$data .= $this->virtualMethod($_);

    } (@{$interfaces});


    return $ret . $data if $data;
}



#
# debugPrint()   : generateCode
#
# Prints the debugPrint function into the code. This could potentially be in the 'dumpStandardSetters'
# code line.
# 
sub debugPrint () {
    my $o =<<'EOF';
sub debugPrint { 
    my $this = shift;
    my $level = shift;
    if ($this->{debug} >= $level || $main::debug >= $level) {
        my ($caller) = (caller(1))[3];
        $caller = "[$caller]:" if $caller;
        my $date = localtime;
        print STDERR $caller . $date . ":" . basename($0) . ":($$): @_.\n" ;
    }
}
EOF

}



#
# trace()   : generateCode
#
# Prints the trace function into the class. This is only printed if the $this->{traceOn}
# field is specified, or the $TRACE environment variable is set.
#
sub trace () {
    my $o =<<'EOF';
sub trace { 
    my $this = shift;
    if ($ENV{TRACE}) {
        my ($caller) = (caller(1))[3];
        if ($ENV{TRACE} =~ /^(t|true|y|yes|1)/i) {            # no-op

        } elsif ($ENV{TRACE} =~ /^(f|false|n|no|0)/i) {       # no tracing
            return 0;
        } else {                                            # assume regexp
            return unless $caller =~ /$ENV{TRACE}/;
        }
        $caller = "TRACE: [$caller]:" if $caller;
        my $date = localtime;
        print STDERR $caller . $date . ":" . basename($0) . ":($$): @_.\n" ;

    }
}
EOF

}


#
# dump()  : thisObjectCode
#
# This is the root expansion code. Calling this on your local PerlObject code
# will go through the work of dumping out the definitions into working Perl code.
# 
sub dump {
    my $this = shift;
    my $ret = "";

    my $ret .= $this->newObject();
    $ret .= $this->constructor() unless $this->{noConstructor};

#
# Process All "valid data items"
#

    $ret .= $this->generateMembers($member);
    $ret .= $this->dumpStandardSetters();
    $ret .= $this->generateInterface();
    $ret .= $this->debugPrint();
    $ret .= $this->trace() if $this->{traceOn};
    if ($this->{where}) {
	$ret .= "
=pod

=head1 FILES

  $this->{where}

=cut
";
    }

    $ret .= $this->finish();

    $ret;
}

1;

#
#  TODO : "required" data for the constructor.
#  
=pod

=head2 TODO

- @ISA management
- setter and getter validation of types
- static data for validation of a "valid" method
- 

=cut

#
